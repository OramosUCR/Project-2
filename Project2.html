<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Oscar Ramos">
<meta name="dcterms.date" content="2025-11-13">

<title>A Computational Review of ranger, A Fast Implementation of Random Forests for High Dimensional Data in C++ and R</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Project2_files/libs/clipboard/clipboard.min.js"></script>
<script src="Project2_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="Project2_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="Project2_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="Project2_files/libs/quarto-html/popper.min.js"></script>
<script src="Project2_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Project2_files/libs/quarto-html/anchor.min.js"></script>
<link href="Project2_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Project2_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Project2_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Project2_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Project2_files/libs/bootstrap/bootstrap-1a08b35c3d36003918d54d257efb4404.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#background" id="toc-background" class="nav-link active" data-scroll-target="#background">Background</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  <li><a href="#review-of-methods" id="toc-review-of-methods" class="nav-link" data-scroll-target="#review-of-methods">Review of Methods</a>
  <ul class="collapse">
  <li><a href="#algorithm-overview-and-computational-aspecs" id="toc-algorithm-overview-and-computational-aspecs" class="nav-link" data-scroll-target="#algorithm-overview-and-computational-aspecs">Algorithm Overview and Computational Aspecs</a>
  <ul class="collapse">
  <li><a href="#parallel-tree-construction" id="toc-parallel-tree-construction" class="nav-link" data-scroll-target="#parallel-tree-construction">1. Parallel Tree Construction</a></li>
  <li><a href="#memory-management" id="toc-memory-management" class="nav-link" data-scroll-target="#memory-management">2. Memory Management</a></li>
  <li><a href="#split-finding-optimization" id="toc-split-finding-optimization" class="nav-link" data-scroll-target="#split-finding-optimization">3. Split Finding Optimization</a></li>
  <li><a href="#data-preprocessing" id="toc-data-preprocessing" class="nav-link" data-scroll-target="#data-preprocessing">4. Data Preprocessing</a></li>
  </ul></li>
  <li><a href="#computational-bottlenecks-and-potential-issues" id="toc-computational-bottlenecks-and-potential-issues" class="nav-link" data-scroll-target="#computational-bottlenecks-and-potential-issues">Computational Bottlenecks and Potential Issues</a>
  <ul class="collapse">
  <li><a href="#memory-bottleneck-for-very-large-p" id="toc-memory-bottleneck-for-very-large-p" class="nav-link" data-scroll-target="#memory-bottleneck-for-very-large-p">1. Memory Bottleneck for Very Large p</a></li>
  <li><a href="#parallelization-overhead" id="toc-parallelization-overhead" class="nav-link" data-scroll-target="#parallelization-overhead">2. Parallelization Overhead</a></li>
  <li><a href="#tree-depth-and-overfitting" id="toc-tree-depth-and-overfitting" class="nav-link" data-scroll-target="#tree-depth-and-overfitting">3. Tree Depth and Overfitting</a></li>
  <li><a href="#split-point-evaluation" id="toc-split-point-evaluation" class="nav-link" data-scroll-target="#split-point-evaluation">4. Split Point Evaluation</a></li>
  <li><a href="#scalability-limits" id="toc-scalability-limits" class="nav-link" data-scroll-target="#scalability-limits">5. Scalability Limits</a></li>
  <li><a href="#missing-value-handling" id="toc-missing-value-handling" class="nav-link" data-scroll-target="#missing-value-handling">6. Missing Value Handling</a></li>
  </ul></li>
  <li><a href="#gaps-and-limitations" id="toc-gaps-and-limitations" class="nav-link" data-scroll-target="#gaps-and-limitations">Gaps and Limitations</a></li>
  </ul></li>
  <li><a href="#technical-examples" id="toc-technical-examples" class="nav-link" data-scroll-target="#technical-examples">Technical Examples</a>
  <ul class="collapse">
  <li><a href="#setup-and-data-preparation" id="toc-setup-and-data-preparation" class="nav-link" data-scroll-target="#setup-and-data-preparation">Setup and Data Preparation</a></li>
  <li><a href="#demonstration-1-classification-with-iris-dataset" id="toc-demonstration-1-classification-with-iris-dataset" class="nav-link" data-scroll-target="#demonstration-1-classification-with-iris-dataset">Demonstration 1: Classification with Iris Dataset</a></li>
  <li><a href="#demonstration-2-regression-with-simulated-high-dimensional-data" id="toc-demonstration-2-regression-with-simulated-high-dimensional-data" class="nav-link" data-scroll-target="#demonstration-2-regression-with-simulated-high-dimensional-data">Demonstration 2: Regression with Simulated High Dimensional Data</a></li>
  <li><a href="#reproducibility" id="toc-reproducibility" class="nav-link" data-scroll-target="#reproducibility">Reproducibility</a></li>
  </ul></li>
  <li><a href="#discussion" id="toc-discussion" class="nav-link" data-scroll-target="#discussion">Discussion</a>
  <ul class="collapse">
  <li><a href="#achievements" id="toc-achievements" class="nav-link" data-scroll-target="#achievements">Achievements</a></li>
  <li><a href="#limitations" id="toc-limitations" class="nav-link" data-scroll-target="#limitations">Limitations</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">A Computational Review of ranger, A Fast Implementation of Random Forests for High Dimensional Data in C++ and R</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Oscar Ramos </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 13, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="background" class="level1">
<h1>Background</h1>
<p>Random forests are among the most widely used machine learning algorithms for classification, regression, and survival analysis. They combine multiple decision trees through bagging and random feature selection to produce robust predictions. However, traditional implementations of random forests face significant computational challenges when dealing with high-dimensional datasets characterized by:</p>
<ul>
<li>Large numbers of observations (n).</li>
<li>Large numbers of features (p).</li>
<li>The need for many trees to achieve optimal performance.</li>
</ul>
<p>The computational challenges become critical when analyzing genomic data, text data, or other modern high dimensional datasets where both n and p can be in the thousands or millions.</p>
</section>
<section id="summary" class="level1">
<h1>Summary</h1>
<p>The paper by Wright and Ziegler (2017) introduces <strong>ranger</strong>, a fast implementation of random forests written in C++ with seamless R integration. The key contributions of this work include:</p>
<ol type="1">
<li><p><strong>Performance Optimization</strong>: ranger achieves significant speedups compared to existing implementations through efficient memory management, optimized data structures, and parallel processing capabilities.</p></li>
<li><p><strong>Memory Efficiency</strong>: The implementation uses memory-efficient data structures that reduce the memory footprint, enabling analysis of larger datasets on standard hardware.</p></li>
<li><p><strong>Comprehensive Functionality</strong>: Unlike many fast implementations that sacrifice features for speed, ranger maintains full compatibility with random forest algorithms including support for classification, regression, and survival analysis.</p></li>
<li><p><strong>User-Friendly Interface</strong>: Despite being written in C++ for performance, ranger provides a clean R interface that is intuitive and compatible with the existing R ecosystem.</p></li>
</ol>
</section>
<section id="review-of-methods" class="level1">
<h1>Review of Methods</h1>
<p>From a computational perspective, the paper addresses several critical algorithmic and implementation challenges:</p>
<ul>
<li><p><strong>Parallel Tree Construction</strong>: Efficient parallelization of tree building across multiple CPU cores.</p></li>
<li><p><strong>Memory-Efficient Data Structures</strong>: Minimizing memory allocation and copying operations during tree construction.</p></li>
<li><p><strong>Optimized Split Finding</strong>: Efficient algorithms for finding optimal splits at each node.</p></li>
<li><p><strong>Data Handling</strong>: Efficient preprocessing and data organization to minimize I/O overhead.</p></li>
<li><p><strong>Scalability</strong>: Ensuring the algorithm scales well with increasing n, p, and number of trees</p></li>
</ul>
<section id="algorithm-overview-and-computational-aspecs" class="level2">
<h2 class="anchored" data-anchor-id="algorithm-overview-and-computational-aspecs">Algorithm Overview and Computational Aspecs</h2>
<p>Random forests work by constructing multiple decision trees, each trained on a bootstrap sample of the data. At each split in a tree, a random subset of features (typically <span class="math inline">\(\sqrt{p}\)</span> for classification) is considered. The final prediction aggregates predictions from all trees.</p>
<p>The ranger implementation follows this standard algorithm but optimizes several computational aspects:</p>
<section id="parallel-tree-construction" class="level3">
<h3 class="anchored" data-anchor-id="parallel-tree-construction">1. Parallel Tree Construction</h3>
<p>Ranger constructs trees in parallel, distributing the work across available CPU cores. This is achieved through:</p>
<ul>
<li>Thread safe data structures.</li>
<li>Efficient work distribution to avoid load imbalance.</li>
<li>Minimal synchronization overhead between threads.</li>
</ul>
</section>
<section id="memory-management" class="level3">
<h3 class="anchored" data-anchor-id="memory-management">2. Memory Management</h3>
<p>The implementation uses several strategies to minimize memory usage:</p>
<ul>
<li><strong>Column-wise Data Storage</strong>: Features are stored column-wise rather than row-wise, which improves cache locality during split finding.</li>
<li><strong>Memory Pool Allocation</strong>: Pre-allocating memory pools reduces allocation overhead.</li>
<li><strong>Efficient Indexing</strong>: Using integer indices instead of copying data when possible.</li>
</ul>
</section>
<section id="split-finding-optimization" class="level3">
<h3 class="anchored" data-anchor-id="split-finding-optimization">3. Split Finding Optimization</h3>
<p>For continuous features, finding the optimal split point requires sorting observations by feature value. Ranger optimizes this by:</p>
<ul>
<li>Incremental sorting strategies that avoid full re sorting at each node.</li>
<li>Early stopping when no improvement is possible.</li>
<li>Efficient handling of missing values.</li>
</ul>
</section>
<section id="data-preprocessing" class="level3">
<h3 class="anchored" data-anchor-id="data-preprocessing">4. Data Preprocessing</h3>
<p>Ranger performs minimal preprocessing:</p>
<ul>
<li><p>Automatic handling of categorical variables.</p></li>
<li><p>Efficient encoding of factors.</p></li>
<li><p>Optional data standardization.</p></li>
</ul>
</section>
</section>
<section id="computational-bottlenecks-and-potential-issues" class="level2">
<h2 class="anchored" data-anchor-id="computational-bottlenecks-and-potential-issues">Computational Bottlenecks and Potential Issues</h2>
<p>Despite the optimizations, several computational challenges and potential bottlenecks remain:</p>
<section id="memory-bottleneck-for-very-large-p" class="level3">
<h3 class="anchored" data-anchor-id="memory-bottleneck-for-very-large-p">1. Memory Bottleneck for Very Large p</h3>
<p>While ranger is memory efficient, datasets with extremely large <span class="math inline">\(p\)</span> (e.g., <span class="math inline">\(p &gt; 10^6\)</span>) can still exhaust available RAM. The column-wise storage helps, but the fundamental <span class="math inline">\(O(n \cdot p)\)</span> memory requirement for storing the data matrix cannot be avoided.</p>
<p><strong>Potential Solutions</strong>:</p>
<ul>
<li>Feature selection before random forest construction.</li>
<li>Using sparse matrix representations for sparse high-dimensional data.</li>
</ul>
</section>
<section id="parallelization-overhead" class="level3">
<h3 class="anchored" data-anchor-id="parallelization-overhead">2. Parallelization Overhead</h3>
<p>For small datasets or when using few trees, the overhead of thread management can outweigh the benefits of parallelization. The optimal number of threads depends on the dataset size and hardware.</p>
</section>
<section id="tree-depth-and-overfitting" class="level3">
<h3 class="anchored" data-anchor-id="tree-depth-and-overfitting">3. Tree Depth and Overfitting</h3>
<p>Deep trees require more computation and memory. While ranger doesn’t explicitly limit tree depth (it grows trees to full depth by default), very deep trees can:</p>
<ul>
<li>Increase computation time quadratically with depth.</li>
<li>Increase memory usage.</li>
<li>Potentially lead to overfitting.</li>
</ul>
</section>
<section id="split-point-evaluation" class="level3">
<h3 class="anchored" data-anchor-id="split-point-evaluation">4. Split Point Evaluation</h3>
<p>For continuous features with many unique values, evaluating all possible split points can be computationally expensive. Ranger uses standard approaches, but very high cardinality features could benefit from:</p>
<ul>
<li>Histogram based split finding.</li>
<li>Approximate methods for split evaluation.</li>
<li>Feature discretization for extremely high cardinality features.</li>
</ul>
</section>
<section id="scalability-limits" class="level3">
<h3 class="anchored" data-anchor-id="scalability-limits">5. Scalability Limits</h3>
<p>While ranger scales well, there are practical limits:</p>
<p><strong>- Very large n</strong>: When <span class="math inline">\(n &gt; 10^8\)</span>, even efficient implementations face challenges.</p>
<p><strong>- Very large B</strong>: Building thousands of trees is time consuming regardless of optimizations.</p>
<p><strong>- I/O Bottleneck</strong>: Loading very large datasets from disk affects runtime.</p>
</section>
<section id="missing-value-handling" class="level3">
<h3 class="anchored" data-anchor-id="missing-value-handling">6. Missing Value Handling</h3>
<p>Ranger handles missing values through surrogate splits, which adds computational overhead. Datasets with many missing values will see performance degradation.</p>
</section>
</section>
<section id="gaps-and-limitations" class="level2">
<h2 class="anchored" data-anchor-id="gaps-and-limitations">Gaps and Limitations</h2>
<ol type="1">
<li><p><strong>GPU Acceleration</strong>: ranger does not utilize GPU acceleration, which could provide significant speedups for very large datasets.</p></li>
<li><p><strong>Distributed Computing</strong>: The implementation is limited to single machine parallelism. For datasets that exceed a single machine’s memory or for very large scale applications, distributed implementations would be needed.</p></li>
<li><p><strong>Incremental Learning</strong>: ranger does not support incremental learning (updating trees with new data), requiring full retraining when new data arrives.</p></li>
<li><p><strong>Feature Importance Computation</strong>: While ranger computes variable importance, the permutation based approach can be computationally expensive for datasets with many features.</p></li>
</ol>
</section>
</section>
<section id="technical-examples" class="level1">
<h1>Technical Examples</h1>
<p>This section provides a working demonstration of ranger, illustrating its usage for classification and regression tasks.</p>
<section id="setup-and-data-preparation" class="level2">
<h2 class="anchored" data-anchor-id="setup-and-data-preparation">Setup and Data Preparation</h2>
<div class="cell" data-layout-align="center">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Install ranger if not already installed</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">!</span><span class="fu">require</span>(<span class="st">"ranger"</span>, <span class="at">quietly =</span> <span class="cn">TRUE</span>)) {</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">install.packages</span>(<span class="st">"ranger"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ranger)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(microbenchmark)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="demonstration-1-classification-with-iris-dataset" class="level2">
<h2 class="anchored" data-anchor-id="demonstration-1-classification-with-iris-dataset">Demonstration 1: Classification with Iris Dataset</h2>
<p>We begin with a simple classification example using the classic iris dataset:</p>
<div class="cell" data-layout-align="center">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(iris)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Split into training and testing sets</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>train_idx <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">nrow</span>(iris), <span class="fl">0.7</span> <span class="sc">*</span> <span class="fu">nrow</span>(iris))</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>train_data <span class="ot">&lt;-</span> iris[train_idx, ]</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>test_data <span class="ot">&lt;-</span> iris[<span class="sc">-</span>train_idx, ]</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Train random forest classifier</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>rf_model <span class="ot">&lt;-</span> <span class="fu">ranger</span>(</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  Species <span class="sc">~</span> ., </span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> train_data,</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="at">num.trees =</span> <span class="dv">500</span>,</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  <span class="at">mtry =</span> <span class="dv">2</span>,</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>  <span class="at">min.node.size =</span> <span class="dv">1</span>,</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>  <span class="at">importance =</span> <span class="st">"permutation"</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Make predictions</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>predictions <span class="ot">&lt;-</span> <span class="fu">predict</span>(rf_model, <span class="at">data =</span> test_data)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate accuracy</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>accuracy <span class="ot">&lt;-</span> <span class="fu">mean</span>(predictions<span class="sc">$</span>predictions <span class="sc">==</span> test_data<span class="sc">$</span>Species)</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"Classification Accuracy:"</span>, <span class="fu">round</span>(accuracy <span class="sc">*</span> <span class="dv">100</span>, <span class="dv">2</span>), <span class="st">"%</span><span class="sc">\n</span><span class="st">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Classification Accuracy: 97.78 %</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Display variable importance</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>importance_df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">Variable =</span> <span class="fu">names</span>(rf_model<span class="sc">$</span>variable.importance),</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">Importance =</span> rf_model<span class="sc">$</span>variable.importance</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>) <span class="sc">%&gt;%</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(Importance))</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(importance_df)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>                 Variable  Importance
Petal.Length Petal.Length 0.320263280
Petal.Width   Petal.Width 0.288060428
Sepal.Length Sepal.Length 0.036755299
Sepal.Width   Sepal.Width 0.008076372</code></pre>
</div>
</div>
</section>
<section id="demonstration-2-regression-with-simulated-high-dimensional-data" class="level2">
<h2 class="anchored" data-anchor-id="demonstration-2-regression-with-simulated-high-dimensional-data">Demonstration 2: Regression with Simulated High Dimensional Data</h2>
<p>We create a simulated high dimensional regression problem to demonstrate ranger’s capability with larger feature spaces:</p>
<div class="cell" data-layout-align="center">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate synthetic high dimensional data</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">456</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">1000</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="dv">100</span>  <span class="co"># Number of features</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Create correlated features</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">rnorm</span>(n <span class="sc">*</span> p), <span class="at">nrow =</span> n, <span class="at">ncol =</span> p)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Add correlation structure</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>X[, <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>] <span class="ot">&lt;-</span> X[, <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>] <span class="sc">+</span> <span class="fl">0.5</span> <span class="sc">*</span> X[, <span class="dv">1</span>]</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co"># True model uses only first 10 features</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="dv">2</span> <span class="sc">*</span> X[, <span class="dv">1</span>] <span class="sc">+</span> <span class="fl">1.5</span> <span class="sc">*</span> X[, <span class="dv">2</span>] <span class="sc">-</span> X[, <span class="dv">3</span>] <span class="sc">+</span> <span class="fl">0.5</span> <span class="sc">*</span> X[, <span class="dv">4</span>] <span class="sc">+</span> </span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>     <span class="fl">0.3</span> <span class="sc">*</span> <span class="fu">rowSums</span>(X[, <span class="dv">5</span><span class="sc">:</span><span class="dv">10</span>]) <span class="sc">+</span> <span class="fu">rnorm</span>(n, <span class="at">sd =</span> <span class="fl">0.5</span>)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Combine into data frame</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>data_df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">y =</span> y, X)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Split data</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>train_idx <span class="ot">&lt;-</span> <span class="fu">sample</span>(n, <span class="fl">0.7</span> <span class="sc">*</span> n)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>train_data <span class="ot">&lt;-</span> data_df[train_idx, ]</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>test_data <span class="ot">&lt;-</span> data_df[<span class="sc">-</span>train_idx, ]</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Train regression model</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>rf_reg <span class="ot">&lt;-</span> <span class="fu">ranger</span>(</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>  y <span class="sc">~</span> ., </span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> train_data,</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>  <span class="at">num.trees =</span> <span class="dv">500</span>,</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>  <span class="at">mtry =</span> <span class="fu">floor</span>(<span class="fu">sqrt</span>(p)),</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>  <span class="at">min.node.size =</span> <span class="dv">5</span>,</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>  <span class="at">importance =</span> <span class="st">"permutation"</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Predictions</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>pred_reg <span class="ot">&lt;-</span> <span class="fu">predict</span>(rf_reg, <span class="at">data =</span> test_data)</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate RMSE</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>rmse <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(<span class="fu">mean</span>((pred_reg<span class="sc">$</span>predictions <span class="sc">-</span> test_data<span class="sc">$</span>y)<span class="sc">^</span><span class="dv">2</span>))</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"Root Mean Squared Error:"</span>, <span class="fu">round</span>(rmse, <span class="dv">4</span>), <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Root Mean Squared Error: 2.1581 </code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"R-squared:"</span>, <span class="fu">round</span>(<span class="dv">1</span> <span class="sc">-</span> <span class="fu">sum</span>((test_data<span class="sc">$</span>y <span class="sc">-</span> pred_reg<span class="sc">$</span>predictions)<span class="sc">^</span><span class="dv">2</span>) <span class="sc">/</span> </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>                        <span class="fu">sum</span>((test_data<span class="sc">$</span>y <span class="sc">-</span> <span class="fu">mean</span>(test_data<span class="sc">$</span>y))<span class="sc">^</span><span class="dv">2</span>), <span class="dv">4</span>), <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>R-squared: 0.7908 </code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Top 10 most important features</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>importance_reg <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">Variable =</span> <span class="fu">names</span>(rf_reg<span class="sc">$</span>variable.importance),</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">Importance =</span> rf_reg<span class="sc">$</span>variable.importance</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>) <span class="sc">%&gt;%</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(Importance)) <span class="sc">%&gt;%</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">head</span>(<span class="dv">10</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(importance_reg)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>    Variable Importance
X1        X1  9.2715611
X2        X2  3.9682064
X4        X4  1.7793203
X8        X8  1.2450704
X7        X7  0.8371822
X10      X10  0.8243311
X6        X6  0.8082263
X9        X9  0.7457960
X5        X5  0.6448321
X3        X3  0.1095110</code></pre>
</div>
</div>
</section>
<section id="reproducibility" class="level2">
<h2 class="anchored" data-anchor-id="reproducibility">Reproducibility</h2>
<p>To ensure full reproducibility of this demonstration:</p>
<ol type="1">
<li><strong>R Version</strong>: This report was generated with R version R version 4.3.3 (2024-02-29)</li>
<li><strong>Package Versions</strong>:
<ul>
<li>ranger: 0.17.0</li>
</ul></li>
<li><strong>Random Seeds</strong>: All random operations use explicit seeds (<code>set.seed()</code>)</li>
<li><strong>System Information</strong>: The demonstrations should run on any system with R and the ranger package installed</li>
</ol>
<p>To reproduce these results:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Install required packages</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">install.packages</span>(<span class="fu">c</span>(<span class="st">"ranger"</span>, <span class="st">"ggplot2"</span>, <span class="st">"dplyr"</span>, <span class="st">"microbenchmark"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
</section>
<section id="discussion" class="level1">
<h1>Discussion</h1>
<section id="achievements" class="level2">
<h2 class="anchored" data-anchor-id="achievements">Achievements</h2>
<p>Ranger represents a significant achievement in computational statistics and machine learning software development. The key accomplishments include:</p>
<ol type="1">
<li><p><strong>Practical Speedups</strong>: ranger achieves substantial speedups (often 5-10x or more) compared to traditional random forest implementations, making it feasible to analyze larger datasets and use more trees for potentially better predictions.</p></li>
<li><p><strong>Accessibility</strong>: By providing a clean R interface, ranger makes high performance random forests accessible to the large R user community without requiring knowledge of C++ or parallel programming.</p></li>
<li><p><strong>Maintained Functionality</strong>: Unlike many “fast” implementations that sacrifice features, ranger maintains full compatibility with standard random forest functionality, including variable importance, out-of-bag predictions, and support for multiple problem types.</p></li>
<li><p><strong>Real World Impact</strong>: ranger has been widely adopted in both research and industry, demonstrating its practical utility. It has enabled analyses that would have been computationally infeasible with slower implementations.</p></li>
</ol>
</section>
<section id="limitations" class="level2">
<h2 class="anchored" data-anchor-id="limitations">Limitations</h2>
<p>Despite its achievements, ranger has some limitations:</p>
<ol type="1">
<li><p><strong>Single Machine Limitation</strong>: ranger is designed for single machine parallelism. For datasets that exceed available memory or require distributed computing, other solutions are needed.</p></li>
<li><p><strong>No GPU Acceleration</strong>: Modern GPU hardware could provide additional speedups for very large datasets, but ranger does not utilize GPU resources.</p></li>
<li><p><strong>Memory Requirements</strong>: While memory efficient, ranger still requires the full dataset to fit in memory. For truly massive datasets (e.g., billions of observations), out-of-core or streaming approaches would be needed.</p></li>
<li><p><strong>Hyperparameter Tuning</strong>: While ranger provides many tuning parameters, there’s limited guidance on optimal parameter selection, and tuning can be time consuming for large datasets.</p></li>
<li><p><strong>Interpretability Trade-offs</strong>: Random forests in general sacrifice some interpretability compared to single trees. While ranger provides variable importance, understanding individual predictions requires additional tools.</p></li>
</ol>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>Ranger successfully addresses the computational challenges of traditional random forest implementations while maintaining full functionality and user accessibility. Its combination of performance optimizations, parallel processing, and clean R interface has made it a valuable tool for both research and practical applications. While limitations exist, particularly regarding single machine constraints and memory requirements, ranger represents a significant step forward in making powerful ensemble methods computationally feasible for high dimensional data analysis.</p>
<p>The computational optimizations demonstrated in ranger such as efficient memory management, parallel processing, and algorithmic improvements, serve as valuable lessons for implementing other machine learning algorithms. As datasets continue to grow in size and dimensionality, tools like ranger will be increasingly essential for practical data analysis.</p>
</section>
<section id="references" class="level1">
<h1>References</h1>
<p>Wright, M. N., &amp; Ziegler, A. (2017). ranger: A Fast Implementation of Random Forests for High Dimensional Data in C++ and R. <em>Journal of Statistical Software</em>, 77(1), 1-17. https://doi.org/10.18637/jss.v077.i01</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>